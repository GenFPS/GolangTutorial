# Константы

Константы также как и переменные хранят данные, но главное их отличие от переменных заключается в том, что значения констант нельзя изменить (они устанавливаются один раз).

Для определения констант применяется ключевое слово `const`:

```
const pi float64 = 3.1415
```

Невозможно менять значение константы:

```
package main

import "fmt"

func main() {
	const pi float64 = 3.1415
	pi = 2.7182

	fmt.Println(pi) // Ошибка (cannot assign to pi (constant 3.1415 of type float64))
}
```

Константы можно объявлять в блоке:

```
func main() {
	const (
	    a int = 1
	    e float32 = 2.7
        pi float64 = 3.1415
    )
}
```

Или так:

```
const pi, e = 3.1415, 2.7
```

Если у константы не указан тип, то он выводится неявно на основании того значения, которым инициализируется константа:

```
const b = 2             // тип int
const pi, e = 3.1415    // тип float64
```

Обязательно необходимо инициализировать константу начальным значением при ее объявлении. Например, следующие определения констант являются недопустимыми, так как они не инициализируются:

```
package main
import "fmt"

func main() {
	const d int

	fmt.Println(d)     // Ошибка (missing init expr for d)
}
```

Если определяется последовательность констант, то инициализацию значением можно опустить для всех констант, кроме первой. В этом случае константа без значения получит значение предыдущей константы:

```
package main
import "fmt"

func main() {
    const (
        a = 2
        b
        c
        d = 4
        e
    )
    fmt.Println(a, b, c, d, e)      // 2, 2, 2, 4, 4
}
```

Константы можно инициализировать только константными значениями. Например, литералами типа чисел или строк, или значениями других констант. Однако инициализировать константу значением какой-либо переменной нельзя:

```
var a int = 5
const b = a         // Ошибка, т.к. m - переменная
const c = 5
const d = c         // Ошибка нет, т.к. с - константа
```

## iota

Ключевое слово `iota` представляет последовательные целочисленные константы 0, 1, 2,…

Это предопределенный идентификатор в языке Go, который в обычном контексте содержит в себе значение 0. Однако в блоках const этот идентификатор увеличивается для каждой следующей константы на единицу. Это позволяет более удобно создавать константы, значения которых предлставляют непрерывную последовательность чисел. Для сравнение можно привести куски кода без `iota` и с `iota`:

```
package main

import "fmt"

func main() {
    const (
	    Zero = 0
	    One = 1
	    Two = 2
	    Three = 3
	    Four = 4
	    Five = 5
    )

    fmt.Println(Zero)    // вывод 0
    fmt.Println(Five)    // вывод 5
}
```

Этот же пример, но с использование `iota`:

```
package main

import "fmt"

func main() {
    const (
	    Zero = iota
	    One
	    Two
	    Three
	    Four
	    Five
    )

    fmt.Println(Zero)    // вывод 0
    fmt.Println(Five)    // вывод 5
}
```

Однако, можно начать не с 0, а с 1, тогда код будет выглядеть следующим образом:

```
package main
import "fmt"

func main() {
    const = (
        a1 = iota + 1
        a2
        a3
    )
    fmt.Println(a1, a2, a3) // 1 2 3
}
```

Также можно использовать пустой идентификатор для того, чтобы пропустить значение в списке констант:

```
package main
import "fmt"

func main() {
    const = (
        a1 = iota + 1
        -
        a3
        a4
    )
    fmt.Println(a1, a3, a4) // 1 3 4
}
```
