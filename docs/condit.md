# Условные выражения и условные конструкции

## Условные выражения

Условные выражения представляют операции отношения и логические операции. Про операции отношения и логические операции мы "вскольз" рассматривали на примере типа данных **bool**, так как они возвращают значение типа **bool**: `true` (если условие истинно) или `false` (если условие ложно).

### Операции отношения

Операции отношения позволяют сравнить два значения. В языке Go есть следующие операции отношения:

`==` — операция "равно"(не путать с операцией присваивания `=`!). Возвращает **true**, если оба операнда равны, и **false**, если они не равны:

```
package main
import "fmt"

func main() {
    var a int = 2
    var b int = 4
    var c bool = a == b

    fmt.Println(c)      // false, так как 2 не равно 4
}
```

`>` — операция "больше чем". Возвращает **true**, если первый операнд больше второго, и **false**, если первый операнд меньше второго или операнды равны:

```
package main
import "fmt"

func main() {
    var a int = 4
    var b int = 2
    var c bool = a > b

    fmt.Println(c)      // true
}
```

`<` — операция "меньше чем". Возвращает **true**, если первый операнд меньше второго, и **false**, если первый операнд больше второго или операнды равны:

```
package main
import "fmt"

func main() {
    var a int = 4
    var b int = 2
    var c bool = a < b

    fmt.Println(c)      // false
}
```

`>=` — операция "больше или равно". Возвращает **true**, если первый операнд больше или равен второму, и **false**, если первый операнд меньше второго:

```
package main
import "fmt"

func main() {
    var a int = 4
    var b int = 4
    var c int = 3

    var d bool = a >= b
    var e bool = a >= c

    fmt.Println(d, e)      // true true
}
```

`<=` — Операция "меньше или равно". Возвращает **true**, если первый операнд меньше или равен второму, и **false**, если первый операнд больше второго:

```
package main
import "fmt"

func main() {
    var a int = 4
    var b int = 4
    var c int = 5

    var d bool = a <= b
    var e bool = a <= c

    fmt.Println(d, e)      // true true
}
```

`!=` — операция "не равно". Возвращает **true**, если первый операнд не равен второму, и **false**, если оба операнда равны:

```
package main
import "fmt"

func main() {
    var a int = 4
    var b int = 2
    var c int = 4

    var d bool = a != b
    var e bool = a != c

    fmt.Println(d, e)      // true false
}
```

### Логические операции

Про логические операции было сказано в теме [**Типы данных**](typeOf.md) раздел **Тип bool**.

## Условные конструкции

Условные выражения являются неотъемлемой частью каждого языка программирования. Условные выражения позволяют создавать код, который будет или не будет выполняться в зависимости от условий в программе на момент запуска.

### Оператор if

Оператор `if` оценивает истинность утверждения и если это утверждение - истина, то запускается следующая часть кода:

```
package main
import "fmt"

func main() {
   a := 7
   b := 7

   if a < b {
      fmt.Println("a меньше, чем b")
  }
}
// программа не выполнится, так как a не меньше чем b
```

Условие ставится после оператора `if`. В данном случае проверяется, меньше ли значение переменной **a**, чем значние переменой **b**. Так как в данном случае значение переменной **a** не меньше значения переменной **b**, то есть условие возвращает **false**, то следующий кусок кода (`fmt.Println("a меньше, чем b"`) проигнорируется.

### Оператор else

Однако, можно задать альтернативную логику, которая выполняется, в случае если условие неверно, то добавляется выражение **else**:

```
package main
import "fmt"

func main() {
   a := 7
   b := 7

   if a < b {
       fmt.Println("a меньше b")
  } esle:
       fmt.Println("а не меньше b")
}
```

Таким образом, если условное выражение после оператора if истинно, то выполняется блок после if, если ложно - выполняется блок после else.

### Выражения else if

Если необходимо проверить несколько альтернативных вариантов, то можно добавить выражения else if:

```
package main
import "fmt"

func main() {
   a := 7
   b := 7

   if a < b {
       fmt.Println("a меньше b")
    } esle if a == b{
       fmt.Println("а равно b")
    } else {
       fmt.Println("а больше b")
    }
}
```

Если выражение после **if** истинно, то срабатывает блок **if**. Иначе проверяется выражение после **else if**. Если оно истинно, то выполняется блок **else if**. Если оно ложно, то выполняется уже блок **else**.

Конструкцию **else if** можно использоваеть неограниченное количество раз:

```
package main
import "fmt"

func main() {
   a := 7
   b := 7

   if a == 7 {
       fmt.Println("a равно 7")
    } else if b == 7{
       fmt.Println("b равно 7")
    } else if a == b{
       fmt.Println("а равно b")
    }
}
```

## Конструкция switch case

В языке Go также существует оператор **switch**, который проверяет значение выражения и с помощью оператора **case** определяются значения для сравнения. Если это значение совападает со значением выражения из **switch**, то выполняется код данного блока **case**:

```
package main
import "fmt"

func main() {
    a := 1
    switch a {
        case 0:
            fmt.Println("a равно 0")
        case 1:
            fmt.Println("a равно 1")    // выполнится этот блок
        case 2:
            fmt.Println("a равно 2")
    }
}
```

А вот так бы выглядел код с использованием кострукций **if/else if**:

```
package main
import "fmt"

func main() {
    a := 1
    if a == 0 {
        fmt.Println("a равно 0")
    } else if a == 1 {
        fmt.Println("a равно 1")
    } else if a == 2 {
        fmt.Println("a равно 2")
    }
}
```

Можно сказать, что второй вариант выглядит болеее громоздко.

### Оператор default

Помимо этого конструкция **switch** может содержать блок **default**, который выполняется, если ни один из операторов case не содержит нужного значения:

```
package main
import "fmt"

func main() {
    a := 3
    switch a {
        case 0:
            fmt.Println("a равно 0")
        case 1:
            fmt.Println("a равно 1")
        case 2:
            fmt.Println("a равно 2")
        default:
            fmt.Println("a больше или равно 3")
    }
}
```

Данный блок не является обязательным, однако он выполняется в случае если не один из **case**'ов не подошел под условие **switch**. По сути оператор **default** является аналогом **else**:

```
package main
import "fmt"

func main() {
    a := 3
    if a == 0 {
        fmt.Println("a равно 0")
    } else if a == 1 {
        fmt.Println("a равно 1")
    } else if a == 2 {
        fmt.Println("a равно 2")
    } else {
        fmt.Println("a больше или равно 3")
    }
}
```

### Оператор fallthrough

Мы выяснили, что если определенный **case** удовлетворяет условию **switch**, то блок кода под этим **case** выполняется и программа на этом завершается. Однако, бывают и такие ситуации, когда нам нужно, чтобы и следующие блоки кода были выполнены, после того, как выполнится истинное условие **case**. Для этого существует оператор **fallthrough**:

```
package main
import "fmt"

func main() {
    a := 1
    switch a {
        case 0:
            fmt.Println("a равно 0")
        case 1:
            fmt.Println("a равно 1")    // выполнится, так как это истина
            fallthrough
        case 2:
            fmt.Println("a равно 2")    // выполнится из-за fallthrough
            fallthrough
        default:
            fmt.Println("a больше или равно 3") // также выполнится из-за fallthrough
    }
}
```

Однако, стоит учесть и тот факт, что если поставить оператор **fallthrough** выше "истинного" **case**'а, то **fallthrough** не сработает:

```
package main
import "fmt"

func main() {
    a := 2
    switch a {
        case 0:
            fmt.Println("a равно 0")
            fallthrough                 // fallthrough не сработает
        case 1:
            fmt.Println("a равно 1")
            fallthrough                // fallthrough также не сработает
        case 2:
            fmt.Println("a равно 2")
            fallthrough               // сработает только в этом случае, т.к. данный case - истина
        default:
            fmt.Println("a больше или равно 3")
    }
}
```
